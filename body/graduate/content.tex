\chapter{绪论}
\section{研究背景及意义}
\section{国内外研究现状}
\section{本文主要工作}
\section{本文结构安排}

\chapter{相关技术}
\section{UWB信道脉冲响应相关技术}
\section{深度学习相关技术}

\chapter{数据采集与预处理}
\section{引言}
\section{使用preamble归一化}
\section{上采样}
Decawave（Qorvo）的 DWM1000 和 NXP 的 NCJ29D5 设备的采样频率为 \(998.4 \, \text{MHz}\)，对应的采样间隔为 \( \Delta \tau = 1.0016 \, \text{ns}\)。
电磁波在空气中的传播速度为 \(c = 299792458 \, \text{m/s}\)，对应的波长为 \(\lambda = 0.2998 \, \text{m}\)。这个精度已经足够满足室内定位的需求。

然而，由于发送和接收设备之间的晶振并不能完全同步，导致接收到的信号的采样的相对开始时间不同步。
有一些研究者提出利用这一不同步来提高信号的采样频率，从而提高定位的精度~\cite{Ledergerber}。
也有一些研究者提出根据 IEEE 802.15.4a 规范~\cite{IEEE_Std_802.15.4a}， UWB CIR 的频谱几乎是矩形，因此可以利用 sinc 插值来提高信号的采样频率~\cite{MAMPI}。

本文借鉴了以上两种方法的思路，通过在频域中添加零来实现对信号的上采样，然后利用逆傅里叶变换（IFFT）将其转回到时域中，对结果取均值来叠加多帧的信息。下面将详细介绍上诉三种方法。

\subsection{均值滤波}
由于接收到的信号的采样的相对开始时间不同步，所以如果把λ分成多个等长的区间，每次采样只会落到其中的同一个区间，通过多次累加可以在每个区间内得到一个均值，从而提高采样率。

均值滤波算法通过以下形式的分段线性函数的系数 \( h = h_0 , h_1 , \ldots , h_{N_{\text{knots}} -1} \) 来跟踪当前测量的信道冲激响应（CIR）的均值：
\[ h(\tau ) = \frac{\tau  - \tau_i}{\Delta \tau_{\text{knots}}} h_i + \frac{\tau  - \tau_i}{\Delta \tau_{\text{knots}}} h_{i +1} \]
其中 \( i \) 满足 \( \tau_i \leq \tau < \tau_{i+1} \)，并且 \( \Delta \tau_{\text{knots}} \) 是分段线性参数化的节点间的间隔。

分段线性参数化的节点 \( \tau_i \) 由以下公式给出：
\[ \tau_i = \tau_{\text{start}} + \Delta \tau_{\text{knots}} \cdot i \]
对于 \( i = \{0, \ldots , N_{\text{knots}} - 1\} \)。

节点总数 \( N_{\text{knots}} \) 由以下公式给出：
\[ N_{\text{knots}} = \frac{\tau_{\text{end}} - \tau_{\text{start}}}{\Delta \tau_{\text{knots}}} + 1 \]

分段线性函数表示CIR的均值计算复杂度低，该算法可以在每个DWM1000模块的主微控制器上运行，这对于实时处理至关重要，并且可以减少用于传输数据的空中时间。
由于其轻量化的特性，使其适用于具有有限内存和计算能力的嵌入式设备，并且可以实时执行。

\subsection{插值法}
本文主要使用了UWB的信道3与信道4。据IEEE 802.15.4a，UWB信道3的中心频率为4492.8Mhz，带宽为449.2Mhz，UWB信道4的中心频率为3993.6，带宽为1331.2Mhz。
信道3,4的频谱图像如图\ref{fig:spectrum_mask}所示，他们的频谱接近矩形，因此可以利用sinc插值来提高信号的采样频率。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{plotted/spectrum_mask}
    \caption{\label{fig:spectrum_mask}UWB信道3，4频谱}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/time.png}
        \caption{\label{fig:time}原始时域图}
    \end{subfigure}%
    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/zero_time.png}
        \caption{\label{fig:zero_time}零填充后的时域图}
    \end{subfigure}
    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/sinc_time.png}
        \caption{\label{fig:sinc_time}sinc插值后的时域图}
    \end{subfigure}

    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/freq.png}
        \caption{\label{fig:freq}原始频域图}
    \end{subfigure}%
    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/zero_freq.png}
        \caption{\label{fig:zero_freq}零填充后的频域图}
    \end{subfigure}
    \begin{subfigure}{0.33\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/interpolation/sinc_freq.png}
        \caption{\label{fig:sinc_freq}sinc插值后的频域图}
    \end{subfigure}
    \caption{sinc插值时频域图}
    \label{fig:interpolation}
\end{figure}

本文以信道3为例，介绍sinc插值的过程。

零填充:
首先，通过在原始数据样本(图\ref{fig:time})之间插入零，
对数据进行上采样。在每个原始数据样点之间插入 \( ( \text{upsample\_factor} - 1) \) 个零。
例如，如果上采样因子为4，那么在每个数据样点之间插入3个零，得到零填充后的时域图(图\ref{fig:zero_time})。
零填充的表达式如下所示：
\[
    x[n] = \{x[0], 0, 0, 0, x[1], 0, 0, 0, x[2], 0, 0, 0, \ldots\}
\]

从频域看，原始的频域图像（图\ref{fig:freq}）变为零填充后的频域图像（图\ref{fig:zero_freq}）。
为了使频域保持一致，需要通过在时域卷积sinc函数实现在频域的低通滤波。

构建 sinc 函数:
构建 sinc 函数以用于插值。sinc 函数是由以下公式定义的：
\[
    \text{sinc}(x) = \dfrac{\sin(\pi x)}{\pi x}
\]

在代码中，sinc 函数的参数是通过时域索引和上采样因子来调整的，以确保 sinc 函数正确对齐在零填充数据的样点上。

\[
    t = \text{np.arange}(-\text{len(zero\_padded\_data)}//2, \text{len(zero\_padded\_data)}//2) * 10^{-9}
\]
\[
    \text{sinc\_func} = \text{np.sinc}(\frac{t \cdot \text{cutoff\_frequency}}{\text{upsample\_factor} })
\]
其中zero\_padded\_data为零填充后的数据，upsample\_factor为上采样因子。
sinc函数的时频域图如\ref{fig:sinc}所示。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\linewidth]{plotted/interpolation/sinc.png}
    \caption{\label{fig:sinc}sinc函数时频图}
\end{figure}

卷积 (Convolution):
使用 sinc 函数对零填充的数据进行卷积，以得到插值的数据。这一步通过数学卷积操作完成，可以通过以下公式表示：
\[
    y[n] = \sum_{k=-\infty}^{\infty} x[k] \cdot \text{sinc\_func}[n - k]
\]

在代码中，这是通过 \texttt{np.convolve} 函数完成的：
\[
    \text{interpolated\_data} = \text{np.convolve}(\text{zero\_padded\_data}, \text{sinc\_func}, \text{mode}='same')
\]
从频域看，这相当于sinc函数与零填充数据的傅里叶变换的乘积，把零填充后的频域图(\ref{fig:zero_freq})转化为 sinc 插值后的频域图(\ref{fig:sinc_freq})。
从而在保证频域一致性的同时提高了时域的采样率

\subsection{fft法}
本文使用的fft法借鉴的sinc插值的原理，sinc插值是在时域上扩充信号，进行拟合，从而达到提高采样率的目的。
fft法直接在频域上进行修改，通过ifft变化得到时域的信号，从而达到提高时域采样率的目的。

\textbf{fft变换：}
首先通过fft把信号从图\ref{fig:time}变换到频域，得到图\ref{fig:freq}。
\[ X[k] = \text{FFT}\{ x[n] \} \]

\textbf{频域补零：}
然后在频域上插入零，得到图\ref{fig:sinc_freq}。这个操作相当于在时域进行上采样和sinc插值。对于4倍上采样，在频域中的每个非零点之间插入3个零，新的频域序列为：
\[ \tilde{X}[k] = \begin{cases}
X[k/4], & \text{if } k \mod 4 = 0 \\
0, & \text{otherwise}
\end{cases} \]

\textbf{ifft变换：}
然后通过ifft变化把图\ref{fig:sinc_freq}变换到时域，得到图\ref{fig:sinc_time}。也就是上采样后的信号。
\[ \tilde{x}[n] = \text{IFFT}\{ \tilde{X}[k] \} \]

相比于sinc插值，fft法的代码量更少，计算量更小，并且更加容易理解。
但是需要注意的是，fft法的频域补零的个数必须为2的整数次幂，否则会导致频域图像出现波纹，从而影响定位精度。

\section{对齐}
对齐主要由两部分组成，一个是对齐采样点，一个是对齐相位。
\begin{figure}[htbp]
    \centering
    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/abs_cir.png}
        \caption{\label{fig:abs_cir}CIR的绝对值}
    \end{subfigure}%
    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/real_imag_cir.png}
        \caption{\label{fig:real_imag_cir}CIR的实部和虚部}
    \end{subfigure}

    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/abs_up_cir.png}
        \caption{\label{fig:abs_up_cir}上采样后的CIR的绝对值}
    \end{subfigure}
    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/real_imag_up_cir.png}
        \caption{\label{fig:real_imag_up_cir}上采样后的CIR的实部和虚部}
    \end{subfigure}%

    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/abs_time_up_cir.png}
        \caption{\label{fig:abs_time_up_cir}对齐采样点后的CIR的绝对值}
    \end{subfigure}
    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/real_imag_time_up_cir.png}
        \caption{\label{fig:real_imag_time_up_cir}对齐采样点后的CIR的实部和虚部}
    \end{subfigure}

    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/abs_time_phase_up_cir.png}
        \caption{\label{fig:abs_time_phase_up_cir}对齐采样点与相位后的CIR的绝对值}
    \end{subfigure}
    \begin{subfigure}{0.47\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{plotted/align/real_imag_time_phase_up_cir.png}
        \caption{\label{fig:real_imag_time_phase_up_cir}对齐采样点与相位后的CIR的实部和虚部}
    \end{subfigure}
    \caption{对齐采样点与相位}
    \label{fig:align}
\end{figure}

\subsection{对齐采样点}
由于DWM1000和NCJ29D5首发不在一个设备上，它们的晶振并不能完全同步，导致接收到的信号的采样的相对开始时间不同步。所以我们需要对采样点进行同步，这样同一个位置的采样点对应的信号传播时间相同。

对于decawave的DWM1000模块，芯片提供first\_path，first\_path是波峰相对于第一个采集点的位置的小数部分，本文使用的数据集都选用了first\_path前4ns作为CIR的起始点。
first\_path是通过decawave内置的波峰检测算法得到的~\cite{dwm1000_user_manual}，数据手册中提及算法的精度是\(\frac{1}{64}\)ns，到达了精度要求，所以对于decawave采集的数据，直接通过first\_path对齐即可。

对于NXP的NCJ29D5模块，芯片没有提供first\_path，所以需要通过其他方法获得first\_path。考虑到CIR信号稳定的特点，本文使用的对齐方法是通过最小距离实现的。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.9\linewidth]{plotted/first_path}
    \caption{\label{fig:first_path}不同起始点的CIR}
\end{figure}

获取first\_path：可以看到，不同起始点的CIR的波形是不一样的，但是它们的波形都是稳定的，所以可以通过最小距离的方法对齐CIR的起始点。

对齐 \texttt{first\_path}：如图 \ref{fig:first_path} 所示，在未通过 \texttt{first\_path} 对齐的情况下，CIR 的起始点是随机的。图中蓝线被略微抬高，以便与橙线区分。

CIR 的最大值代表没有经过任何反射的直射信号，对应的距离为0。而 \texttt{first\_path} 就是这个0距离点相对于第一个采样点的位置的小数部分。不同样本在对齐前，同一采样点对应的距离是不同的。

图中蓝线的 \texttt{first\_path} 为 \(0.25\, \text{ns}\)，橙线的 \texttt{first\_path} 为 \(0.5\, \text{ns}\)。为了对齐蓝线与橙线，本文舍弃蓝线前 \(0.25\, \text{ns}\) 的数据，舍弃橙线前 \(0.5\, \text{ns}\) 的数据，从而实现对齐。

由于不同的 CIR 的 \texttt{first\_path} 不同，它们舍弃的数据长度也不同。在64倍采样的情况下，舍弃的数据长度在0到63之间波动，我们会保留 \((\texttt{CIR\_LEN}-1) \times 64\) 个对齐好的采样点，这时每个样本同一采样点对应的距离相同。

具体的效果如图 \ref{fig:align} 所示。经过上采样后，CIR 由图 \ref{fig:abs_cir} 变为图 \ref{fig:abs_up_cir}，此时 CIR 还未通过 \texttt{first\_path} 对齐。可以看到两条 CIR 数据虽然波形稳定，但是在水平方向有一个明显的偏差，这说明采样点没有对齐。在经过 \texttt{first\_path} 对齐后，我们得到图 \ref{fig:abs_time_up_cir}，完成对于采样点的对齐。

\subsection{对齐相位}
完成采样点对齐后，如图\ref{fig:abs_time_up_cir}所示，我们可以看到复数信号的绝对值已经对齐。
然而，复数信号除了绝对值外，还包含相位信息。由于发送和接收设备之间的晶振不能完全同步，每次采样的初始相位都会有所不同。
因此，即使完成了采样点对齐，如图\ref{fig:real_imag_time_up_cir}所示的实部和虚部图也不能直接使用。

借助于CIR信号的稳定性，本文尝试对基于I/Q的CIR测量值 \( X \) 进行相位对齐，目标是最小化不同CIR数据相位的曼哈顿距离，从而最小化相位偏移的影响。
本文借鉴了\cite{IQ9452299}提出的算法，该算法的核心思想是通过小步旋转预处理的 \( X_{\text{obs}} \)，
并计算旋转后的观测 \( X_{\text{rot}} \) 和参考 \( X_{\text{ref}} \) 之间的差异。
为了减少原算法的计算量，我们首先将first\_path位置的复数信号旋转到0相位，具体公式如下：
\[
X_{\text{start}} = X_{\text{obs}} \cdot e^{-j \cdot \text{angle}(X_{\text{obs}}[\text{first\_path}])}
\]
接下来，我们通过以下方式以小步旋转初始相位 \( X_{\text{start}} \)：
\[
X_{\text{rot}} = X_{\text{start}} \cdot e^{j\theta}
\]
每次旋转后，我们计算参考 \( X_{\text{ref}} \) 和旋转观测 \( X_{\text{rot}} \) 之间的 \( \ell_1 \)-距离：
\[
d_{\ell_1}(X_{\text{ref}}, X_{\text{rot}}) = \sum_{n=1}^N |X_{\text{ref}}[n] - X_{\text{rot}}[n]|
\]
在预定义的相位范围\((-5^\circ,5^\circ)\)内旋转 \( X_{\text{start}} \) 后，我们找到所有计算的 \( \ell_1 \)-距离的最小值：
\[
\hat{X} = \arg\min d_{\ell_1}(X_{\text{ref}}, X_{\text{rot}})
\]
其中 \( d_{\ell_1}(X_{\text{ref}}, X_{\text{rot}}) = \{d_{\ell_1}(X_{\text{ref}}, X_{\text{rot}})\} \) 是所有计算的 \( \ell_1 \)-距离的集合。最小值 \( \hat{X} \) 表示了最佳匹配。
经过相位对齐后本文得到图\ref{fig:real_imag_time_phase_up_cir}。


\section{异常值剔除}
\section{方差图}

\chapter{定位}

\chapter{脚踢}

\section{引言}
\section{采集设备}
\section{模型训练}
\section{模型部署}





\chapter{呼吸}

\chapter{总结与展望}

\chapter{关于本模板}

本模板根据浙江大学研究生院编写的《浙江大学研究生学位论文编写规则》~\cite{zjugradthesisrules}，
在原有的 zjuthesis 模板~\cite{zjuthesis}基础上开发而来。

本模板的本科生版本\cite{zjuthesisrules}得到了浙江大学本科生院老师的支持与审核，
已经在本科生院网上公示。
但当前的研究生版本并未经过研究生院老师的审核，
同学们使用时要注意对照模板与要求，
切不可盲目使用。

作者本人并未编写过浙江大学研究生毕业论文，
所以不清楚具体要求。
如果有热心同学愿意帮忙，
可以替我联系相关老师，我会配合审核并修改代码。

\section{Overleaf 使用注意事项}

如果你在Overleaf上编译本模板，请注意如下事项：

\begin{itemize}
    \item 删除根目录的 ``.latexmkrc'' 文件，否则编译失败且不报任何错误
    \item 字体有版权所以本模板不能附带字体，请务必手动上传字体文件，并在各个专业模板下手动指定字体。
          具体方法参照 GitHub 主页的说明。
    \item 当前的Overleaf默认使用TexLive 2017进行编译，但一些伪粗体复制乱码的问题需要TexLive 2019版本来解决。
          所以各位同学可以在Overleaf上编写论文时务必切换到TexLive 2019或更新版本来编译，以免产生查重相关问题。
          具体说明参照 GitHub 主页。
\end{itemize}


\section{节标题}

我们可以用includegraphics来插入现有的jpg等格式的图片，
如\autoref{fig:zju-logo}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:zju-logo}浙江大学LOGO}
\end{figure}


\subsection{小节标题}


\par 如\autoref{tab:sample}所示，这是一张自动调节列宽的表格。

\begin{table}[htbp]
    \caption{\label{tab:sample}自动调节列宽的表格}
    \begin{tabularx}{\linewidth}{c|X<{\centering}}
        \hline
        第一列 & 第二列 \\ \hline
        xxx & xxx \\ \hline
        xxx & xxx \\ \hline
        xxx & xxx \\ \hline
    \end{tabularx}
\end{table}


\par 如\autoref{equ:sample}，这是一个公式

\begin{equation}
    \label{equ:sample}
    A=\overbrace{(a+b+c)+\underbrace{i(d+e+f)}_{\text{虚数}}}^{\text{复数}}
\end{equation}

\chapter{另一章}


\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{example-image-a}
    \caption{\label{fig:fig-placeholder}图片占位符}
\end{figure}

\chapter{再一章}

\par 如\autoref{alg:sample}，这是一个算法

\begin{algorithm}[H]
    \begin{algorithmic} % enter the algorithmic environment
        \REQUIRE $n \geq 0 \vee x \neq 0$
        \ENSURE $y = x^n$
        \STATE $y \Leftarrow 1$
        \IF{$n < 0$}
        \STATE $X \Leftarrow 1 / x$
        \STATE $N \Leftarrow -n$
        \ELSE
        \STATE $X \Leftarrow x$
        \STATE $N \Leftarrow n$
        \ENDIF
        \WHILE{$N \neq 0$}
        \IF{$N$ is even}
        \STATE $X \Leftarrow X \times X$
        \STATE $N \Leftarrow N / 2$
        \ELSE[$N$ is odd]
        \STATE $y \Leftarrow y \times X$
        \STATE $N \Leftarrow N - 1$
        \ENDIF
        \ENDWHILE
    \end{algorithmic}
    \caption{\label{alg:sample}算法样例}
\end{algorithm}